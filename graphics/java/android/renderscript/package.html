<HTML>
<BODY>
<p>The Renderscript rendering and computational APIs offer a low-level, high performance means of
carrying out mathematical calculations and 3D graphics rendering.</p>

<p>For more information, see the
<a href="{@docRoot}guide/topics/graphics/renderscript.html">Renderscript</a> developer guide.</p>
{@more}

<p>An example of Renderscript in applications include the 3D carousel view that is present in
Android 3.0 applications such as the Books and YouTube applications. This API is intended for
developers who are comfortable working with native code and want to maximize their performance
critical applications.</p>

<p>Renderscript adopts a control and slave architecture where the low-level native code is controlled by the
higher level Android system that runs in the virtual machine (VM). The VM code handles resource
allocation and lifecycle management of the Renderscript enabled application and calls the Renderscript
code through high level entry points. The Android build tools generate these entry points through reflection on
the native Renderscript code, which you write in C (C99 standard). The Renderscript code
does the intensive computation and returns the result back to the Android VM.</p>

<p>You can find the Renderscript native
APIs in the <code>&lt;sdk_root&gt;/platforms/android-11/renderscript</code> directory.
The Android system APIs are broken into a few main groups:</p>

<h4>Core</h4>
<p>These classes are used internally by the system for memory allocation. They are used by the classes that
are generated by the build tools:</p>
<ul>
  <li>Allocation</li>
  <li>Element</li>
  <li>Type</li>
  <li>Script</li>
</ul>


<h4>Data Types</h4>
<p>These data types are used by the classes that are generated
by the build tools. They are the reflected counterparts of the native data types that
are defined by the native Renderscript APIs and used by your Renderscript code. The
classes include:</p>
<ul>
  <li>Byte2, Byte3, and Byte4</li>
  <li>Float2, Float3, Float4</li>
  <li>Int2, Int3, Int4</li>
  <li>Long2, Long3, Long4</li>
  <li>Matrix2f, Matrix3f, Matrix4f</li>
  <li>Short2, Short3, Short4</li>
</ul>

<p>For example, if you declared the following struct in your .rs Renderscript file:</p>

<pre>struct Hello { float3 position; rs_matrix4x4 transform; }</pre>

<p>The build tools generate a class through reflection that looks like the following:</p>
<pre>
class Hello {
    static public class Item {
        Float4 position;
        Matrix4f transform;
    }
Element createElement(RenderScript rs) {
        Element.Builder eb = new Element.Builder(rs);
        eb.add(Element.F32_3(rs), "position");
        eb.add(Element.MATRIX_4X4(rs), "transform");
        return eb.create();
    }
}
</pre>

<h4>Graphics</h4>
<p>These classes are specific to graphics Renderscripts and support a typical rendering
pipeline.</p>
<ul>
<li>Mesh</li>
<li>ProgramFragment</li>
<li>ProgramRaster</li>
<li>ProgramStore</li>
<li>ProgramVertex</li>
<li>RSSurfaceView</li>
<li>Sampler</li>
</ul>

</p>
</BODY>
</HTML>
